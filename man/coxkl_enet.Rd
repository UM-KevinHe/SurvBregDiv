% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/coxkl_enet.R
\name{coxkl_enet}
\alias{coxkl_enet}
\title{Cox Proportional Hazards Model with KL Divergence and Elastic Net Penalty}
\usage{
coxkl_enet(
  z,
  delta,
  time,
  stratum = NULL,
  RS = NULL,
  beta = NULL,
  eta = NULL,
  alpha = NULL,
  lambda = NULL,
  nlambda = 100,
  lambda.min.ratio = ifelse(n < p, 0.05, 0.001),
  lambda.early.stop = FALSE,
  tol = 1e-04,
  Mstop = 1000,
  max.total.iter = (Mstop * nlambda),
  group = 1:ncol(z),
  group.multiplier = NULL,
  standardize = T,
  nvar.max = ncol(z),
  group.max = length(unique(group)),
  stop.loss.ratio = 0.01,
  actSet = TRUE,
  actIter = Mstop,
  actGroupNum = sum(unique(group) != 0),
  actSetRemove = F,
  returnX = FALSE,
  trace.lambda = FALSE,
  message = FALSE,
  data_sorted = FALSE,
  ...
)
}
\arguments{
\item{z}{Numeric matrix of covariates (predictors). Rows are observations, columns are variables.}

\item{delta}{Numeric vector of event indicators (1 = event, 0 = censored).}

\item{time}{Numeric vector of follow-up times (observed event or censoring time).}

\item{stratum}{Optional numeric or factor vector for stratified analysis.}

\item{RS}{Optional numeric vector of external risk scores. Length must equal \code{nrow(z)}.
If not provided, \code{beta} must be supplied.}

\item{beta}{Optional numeric vector of external coefficients. Length must equal \code{ncol(z)}.
If provided, it is used to calculate risk scores. If not provided, \code{RS} must be supplied.}

\item{eta}{Numeric scalar. The tuning parameter for KL divergence (integration strength).
Defaults to 0 (no external information).}

\item{alpha}{The Elastic Net mixing parameter, with \eqn{0 < \alpha \le 1}.
\code{alpha = 1} is the lasso penalty, and \code{alpha} close to 0 approaches ridge.
Defaults to 1.}

\item{lambda}{Optional numeric vector of penalty parameters. If \code{NULL}, a path is generated automatically.}

\item{nlambda}{Integer. The number of lambda values to generate. Default is 100.}

\item{lambda.min.ratio}{Numeric. The ratio of the smallest to the largest lambda in the sequence.
Default depends on sample size relative to features (0.05 if n < p, else 1e-3).}

\item{lambda.early.stop}{Logical. If \code{TRUE}, stops the lambda path early if the loss improvement is small.}

\item{tol}{Numeric. Convergence tolerance for the optimization. Default is 1e-4.}

\item{Mstop}{Integer. Maximum iterations for the inner loop per lambda. Default is 1000.}

\item{max.total.iter}{Integer. Maximum total iterations across the entire path.}

\item{group}{Integer vector defining group membership for grouped penalties.
Default treats each variable as its own group.}

\item{group.multiplier}{Numeric vector. Multiplicative factors for penalties applied to each group.}

\item{standardize}{Logical. If \code{TRUE}, \code{z} is standardized internally.
Coefficients are returned on the original scale.}

\item{nvar.max}{Integer. Maximum number of active variables allowed.}

\item{group.max}{Integer. Maximum number of active groups allowed.}

\item{stop.loss.ratio}{Numeric. Threshold for early stopping based on loss ratio.}

\item{actSet}{Logical. If \code{TRUE}, uses an active-set strategy for optimization.}

\item{actIter}{Integer. Iterations for active set refinement.}

\item{actGroupNum}{Integer. Limit on active groups in active set strategy.}

\item{actSetRemove}{Logical. Whether to allow removal from the active set.}

\item{returnX}{Logical. If \code{TRUE}, returns the standardized design matrix and data in the result.}

\item{trace.lambda}{Logical. If \code{TRUE}, prints the lambda sequence progress.}

\item{message}{Logical. If \code{TRUE}, prints informative messages during fitting.}

\item{data_sorted}{Logical. Internal use. Indicates if data is already sorted by time/stratum.}

\item{...}{Additional arguments.}
}
\value{
An object of class \code{"coxkl_enet"}. A list containing:
\describe{
\item{\code{beta}}{Matrix of coefficient estimates (p x nlambda).}
\item{\code{lambda}}{The sequence of lambda values used.}
\item{\code{alpha}}{The elastic-net mixing parameter used.}
\item{\code{likelihood}}{Vector of negative log-partial likelihoods (loss) for each lambda.}
\item{\code{df}}{Vector of degrees of freedom (number of non-zero coefficients) for each lambda.}
\item{\code{iter}}{Vector of iteration counts for each lambda.}
\item{\code{W}}{Matrix of exponentiated linear predictors (risk scores) on the original scale.}
\item{\code{data}}{List containing the input data used.}
}
}
\description{
Fits a Cox proportional hazards model that integrates external information
using Kullbackâ€“Leibler (KL) divergence, while applying an Elastic Net
(Lasso + Ridge) penalty for variable selection and regularization.

External information can be provided as:
\itemize{
\item \code{RS}: Precomputed external risk scores.
\item \code{beta}: Externally derived coefficients (which are converted to risk scores internally).
}
The strength of integration is controlled by the tuning parameter \code{eta}.
}
\details{
The objective function optimizes the partial likelihood penalized by the KL divergence
from the external information and the Elastic Net norm.
\itemize{
\item If \code{eta = 0}, the method reduces to a standard Elastic Net Cox model (ignoring external info).
\item If \code{alpha = 1}, the penalty is Lasso.
\item If \code{alpha} is close to 0, the penalty approaches Ridge.
}
}
\examples{
\dontrun{
data(ExampleData_highdim)
train_dat_highdim <- ExampleData_highdim$train
beta_external_highdim <- ExampleData_highdim$beta_external

# Fit the Elastic Net Cox model with KL divergence
coxkl_enet_est <- coxkl_enet(
  z = train_dat_highdim$z,
  delta = train_dat_highdim$status,
  time = train_dat_highdim$time,
  stratum = train_dat_highdim$stratum,
  beta = beta_external_highdim,
  eta = 0  # eta=0 implies standard elastic net (ignoring external beta)
)
}

}
