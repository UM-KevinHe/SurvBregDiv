#' Simulate stratified Cox PH survival data with flexible censoring, optional binary covariates, and optional ties
#'
#' @description
#' Internal function to generate time-to-event data under a stratified Cox proportional hazards model
#' with high-dimensional covariates, stratum-specific multiplicative baseline scaling, and
#' controllable random censoring. Event times are generated by inverse transform sampling using the
#' baseline cumulative hazard.
#'
#' The model is
#' \deqn{h(t \mid Z, s) = \gamma_s \, h_0(t)\, \exp(Z^\top \beta),}
#' where \eqn{\gamma_s} is a stratum-specific positive constant, \eqn{h_0(t)} is the baseline hazard,
#' and \eqn{\beta} is the coefficient vector.
#'
#' Supported baseline hazards:
#' \itemize{
#'   \item \code{"exponential"}: \eqn{h_0(t)=1}, so \eqn{H_0(t)=t}.
#'   \item \code{"weibull"}: \eqn{h_0(t)=\alpha t} with \eqn{\alpha>0}, so \eqn{H_0(t)=\alpha t^2/2}.
#' }
#'
#' Censoring is implemented as
#' \deqn{T_{\mathrm{obs}} = \min(T, C, \texttt{max_time}),}
#' where \eqn{C} is a random censoring time drawn from a specified distribution and calibrated to
#' approximately match the target censoring rate.
#'
#' Supported random censoring distributions:
#' \itemize{
#'   \item \code{"uniform"}: \eqn{C \sim \mathrm{Unif}(0, c_{\max})}.
#'   \item \code{"exponential"}: \eqn{C \sim \mathrm{Exp}(\lambda_c)}.
#'   \item \code{"weibull"}: \eqn{C \sim \mathrm{Weibull}(k, \lambda_c)}, with shape \eqn{k} specified by
#'     \code{censor_weibull_shape}.
#'   \item \code{"lognormal"}: \eqn{C \sim \mathrm{LogNormal}(\mu_c, \sigma_c^2)}, with
#'     \eqn{\sigma_c} specified by \code{censor_lognormal_sdlog}.
#'   \item \code{"none"}: no random censoring; only administrative censoring via \code{max_time}.
#' }
#'
#' Binary covariates can be specified by index via \code{binary_idx}. These variables are generated
#' using a latent Gaussian threshold model to achieve a desired prevalence and an approximate
#' within-binary correlation controlled by \code{rho_binary}. Specifically, if \eqn{B} is binary with
#' \eqn{P(B=1)=p}, it is generated as \eqn{B = I(L > c)} where \eqn{L} is standard normal and
#' \eqn{c=\Phi^{-1}(1-p)}. When multiple binary covariates are requested, their latent variables are
#' generated jointly with an equicorrelation \code{rho_binary}. This controls latent (tetrachoric)
#' correlation; the resulting Pearson correlation among binary variables is constrained by prevalence
#' and will generally be close but not identical to \code{rho_binary}.
#'
#' If \code{ties=TRUE}, observed times are discretized into \code{ties_levels} bins (based on sample
#' quantiles) and replaced by bin midpoints to induce tied event/censoring times. Smaller
#' \code{ties_levels} produces stronger ties.
#'
#' @param n_stratum Integer. Number of strata.
#' @param n.beta Integer. Total number of covariates \eqn{p}.
#' @param beta_value_vec Numeric vector. True coefficients for the first
#'   \code{length(beta_value_vec)} covariates. Remaining coefficients (up to \code{n.beta}) are set
#'   to 0.
#' @param beta_idx Integer vector or \code{NULL}. Indices (in \code{1:n.beta}) of covariates with
#'   nonzero true coefficients. If \code{NULL}, defaults to \code{1:length(beta_value_vec)} (the
#'   original behavior). Must have the same length as \code{beta_value_vec} after filtering to
#'   valid indices.
#' @param mu_Z Numeric vector or \code{NULL}. Mean vector for the continuous covariates. If
#'   \code{NULL}, a zero vector is used. For indices in \code{binary_idx}, \code{mu_Z} is ignored.
#' @param stratum_size Integer or numeric vector. Stratum sample sizes. If a scalar, it is recycled
#'   to length \code{n_stratum}; if a vector, it must have length \code{n_stratum}.
#' @param rho Numeric. Correlation parameter in \eqn{[0,1)} for the equicorrelation covariance
#'   structure used to generate continuous covariates.
#' @param censor_rate Numeric. Target random censoring rate in \eqn{[0,1)}. If 0, no random censoring
#'   is applied (administrative censoring via \code{max_time} may still apply).
#' @param censor_type Character. Random censoring distribution. One of \code{"uniform"},
#'   \code{"exponential"}, \code{"weibull"}, \code{"lognormal"}, or \code{"none"}.
#' @param max_time Numeric. Administrative censoring time. Observed time is
#'   \code{min(event, censor, max_time)}.
#' @param seed Integer or \code{NULL}. Random seed for reproducibility.
#' @param baseline Character. Baseline hazard type. One of \code{"exponential"} or \code{"weibull"}.
#' @param alpha Numeric or \code{NULL}. Required when \code{baseline="weibull"}. Controls the Weibull
#'   baseline hazard \eqn{h_0(t)=\alpha t}; must be positive and finite. Ignored when
#'   \code{baseline="exponential"}.
#' @param censor_weibull_shape Numeric. Shape parameter \eqn{k>0} for Weibull random censoring when
#'   \code{censor_type="weibull"}. The scale parameter is calibrated internally to match
#'   \code{censor_rate}. Ignored otherwise.
#' @param censor_lognormal_sdlog Numeric. Log-scale standard deviation \eqn{\sigma_c>0} for log-normal
#'   random censoring when \code{censor_type="lognormal"}. The mean on the log scale is calibrated
#'   internally to match \code{censor_rate}. Ignored otherwise.
#' @param binary_idx Integer vector. Indices (in \code{1:n.beta}) of covariates to be generated as
#'   binary. Default is none (all covariates continuous).
#' @param binary_prev Numeric scalar or vector. Prevalence \eqn{P(Z_j=1)} for binary covariates. If a
#'   scalar, it is recycled to all binary covariates. Must be in \eqn{(0,1)}.
#' @param rho_binary Numeric. Equicorrelation parameter in \eqn{[0,1)} for the latent Gaussian vector
#'   used to generate binary covariates. Ignored if \code{binary_idx} is empty.
#' @param ties Logical. If \code{TRUE}, discretize observed times to induce ties.
#' @param ties_levels Integer. Number of bins used to discretize time when \code{ties=TRUE}. Smaller
#'   values yield stronger ties. Must be \eqn{\ge 2}.
#'
#' @return A list with components:
#' \itemize{
#'   \item \code{data_combined}: A \code{data.frame} with columns \code{stratum}, \code{status},
#'     \code{time}, and covariates \code{Z1...Zp}.
#'   \item \code{data}: A list containing \code{stratum}, \code{Z}, \code{time}, and \code{status}.
#'   \item \code{true_beta}: Numeric vector of length \code{n.beta} with the true coefficients used.
#'   \item \code{meta}: A list of metadata including stratum parameters, baseline settings, censoring
#'     configuration, binary-covariate configuration, ties configuration, and the actual censoring
#'     rate achieved.
#' }
#'
#' @details
#' Continuous covariates (those not in \code{binary_idx}) are generated independently within each
#' stratum from a multivariate normal distribution with mean given by \code{mu_Z} (restricted to the
#' continuous indices) and an equicorrelation covariance matrix with diagonal 1 and off-diagonal
#' \code{rho}.
#'
#' Stratum-specific scaling factors are sampled as \eqn{\gamma_s \sim \mathrm{Unif}(0,2)} and applied
#' multiplicatively to the hazard.
#'
#' For \code{baseline="weibull"}, the implied event-time distribution (conditional on \eqn{Z} and
#' stratum) is Weibull with shape 2 under the parameterization \eqn{h_0(t)=\alpha t}.
#'
#' @keywords internal
#' @export
sim.cox.highdim <- function(n_stratum = 1,
                            n.beta,
                            beta_value_vec,
                            beta_idx = NULL,
                            mu_Z = NULL,
                            sd_Z = NULL,
                            stratum_size = 1e3,
                            rho = 0.1,
                            censor_rate = 0.30,
                            censor_type = c("uniform", "exponential", "weibull", "lognormal", "none"),
                            max_time = Inf,
                            seed = NULL,
                            baseline = c("exponential", "weibull"),
                            alpha = NULL,
                            censor_weibull_shape = 1.5,
                            censor_lognormal_sdlog = 1.0,
                            binary_idx = integer(0),
                            binary_prev = 0.5,
                            rho_binary = 0.1,
                            ties = FALSE,
                            ties_levels = 50) {

  if (!is.null(seed)) set.seed(seed)

  censor_type <- match.arg(tolower(censor_type), c("uniform", "exponential", "weibull", "lognormal", "none"))
  baseline <- match.arg(tolower(baseline), c("exponential", "weibull"))

  if (!is.finite(rho) || rho < 0 || rho >= 1) stop("rho must be in [0,1).")
  if (!is.finite(rho_binary) || rho_binary < 0 || rho_binary >= 1) stop("rho_binary must be in [0,1).")
  if (!is.finite(censor_rate) || censor_rate < 0 || censor_rate >= 1) stop("censor_rate must be in [0,1).")

  if (baseline == "weibull") {
    if (is.null(alpha) || !is.finite(alpha) || alpha <= 0) {
      stop("For baseline='weibull', alpha must be a positive finite number.")
    }
  }

  if (censor_type == "weibull") {
    if (!is.finite(censor_weibull_shape) || censor_weibull_shape <= 0) {
      stop("For censor_type='weibull', censor_weibull_shape must be a positive finite number.")
    }
  }

  if (censor_type == "lognormal") {
    if (!is.finite(censor_lognormal_sdlog) || censor_lognormal_sdlog <= 0) {
      stop("For censor_type='lognormal', censor_lognormal_sdlog must be a positive finite number.")
    }
  }

  if (!is.logical(ties) || length(ties) != 1) stop("ties must be TRUE/FALSE.")
  if (!is.finite(ties_levels) || ties_levels < 2) stop("ties_levels must be an integer >= 2.")
  ties_levels <- as.integer(ties_levels)

  binary_idx <- unique(as.integer(binary_idx))
  binary_idx <- binary_idx[binary_idx >= 1 & binary_idx <= n.beta]
  cont_idx <- setdiff(seq_len(n.beta), binary_idx)

  if (length(binary_idx) > 0) {
    if (length(binary_prev) == 1) {
      binary_prev_vec <- rep(binary_prev, length(binary_idx))
    } else if (length(binary_prev) == length(binary_idx)) {
      binary_prev_vec <- as.numeric(binary_prev)
    } else {
      stop("binary_prev must be a scalar or have the same length as binary_idx.")
    }
    if (any(!is.finite(binary_prev_vec)) || any(binary_prev_vec <= 0) || any(binary_prev_vec >= 1)) {
      stop("binary_prev values must be in (0,1).")
    }
  } else {
    binary_prev_vec <- numeric(0)
  }

  if (is.null(mu_Z)) {
    mu_vec <- rep(0, n.beta)
  } else {
    if (length(mu_Z) != n.beta) stop("Length of mu_Z must equal n.beta")
    mu_vec <- as.numeric(mu_Z)
  }

  if (is.null(sd_Z)) {
    sd_vec_all <- rep(1, n.beta)
  } else {
    if (length(sd_Z) == 1) {
      sd_vec_all <- rep(as.numeric(sd_Z), n.beta)
    } else if (length(sd_Z) == n.beta) {
      sd_vec_all <- as.numeric(sd_Z)
    } else if (length(sd_Z) == length(cont_idx)) {
      sd_vec_all <- rep(1, n.beta)
      sd_vec_all[cont_idx] <- as.numeric(sd_Z)
    } else {
      stop("sd_Z must be NULL, a scalar, length n.beta, or length equal to the number of continuous covariates.")
    }
    if (any(!is.finite(sd_vec_all)) || any(sd_vec_all <= 0)) {
      stop("sd_Z values must be positive finite numbers.")
    }
  }

  if (length(stratum_size) == 1) {
    current_stratum_size <- rep(stratum_size, n_stratum)
  } else if (length(stratum_size) == n_stratum) {
    current_stratum_size <- stratum_size
  } else {
    stop("stratum_size must be scalar or length n_stratum")
  }

  if (is.null(beta_idx)) {
    beta_idx_use <- seq_len(length(beta_value_vec))
  } else {
    beta_idx_use <- as.integer(beta_idx)
  }

  ok <- beta_idx_use >= 1 & beta_idx_use <= n.beta & is.finite(beta_idx_use)
  beta_idx_use <- beta_idx_use[ok]

  if (length(beta_idx_use) != length(beta_value_vec)) {
    stop("beta_idx must have the same length as beta_value_vec after filtering to valid indices in 1:n.beta.")
  }
  if (anyDuplicated(beta_idx_use) > 0) stop("beta_idx must not contain duplicates.")

  beta <- rep(0, n.beta)
  if (length(beta_value_vec) > 0) beta[beta_idx_use] <- as.numeric(beta_value_vec)

  stratum_id <- rep(seq_len(n_stratum), current_stratum_size)
  N <- sum(current_stratum_size)

  gamma_stratum <- runif(n_stratum, 0, 2)
  gamma_subject <- gamma_stratum[stratum_id]

  rZ_cont <- function(current_n, mu, rho, p, sd_vec) {
    if (p == 0) return(matrix(numeric(0), nrow = current_n, ncol = 0))
    R <- diag(1 - rho, p) + matrix(rho, p, p)
    D <- diag(sd_vec, p)
    Sigma <- D %*% R %*% D
    MASS::mvrnorm(n = current_n, mu = mu, Sigma = Sigma)
  }

  rZ_bin <- function(current_n, prev_vec, rho_bin) {
    q <- length(prev_vec)
    if (q == 0) return(matrix(numeric(0), nrow = current_n, ncol = 0))
    Sigma <- diag(1 - rho_bin, q) + matrix(rho_bin, q, q)
    L <- MASS::mvrnorm(n = current_n, mu = rep(0, q), Sigma = Sigma)
    thr <- qnorm(1 - prev_vec)
    B <- sweep(L, 2, thr, `>`)
    1 * B
  }

  Z_list <- lapply(seq_len(n_stratum), function(i) {
    n_i <- current_stratum_size[i]
    Z_cont <- rZ_cont(
      n_i,
      mu = mu_vec[cont_idx],
      rho = rho,
      p = length(cont_idx),
      sd_vec = sd_vec_all[cont_idx]
    )
    Z_bin <- rZ_bin(n_i, prev_vec = binary_prev_vec, rho_bin = rho_binary)

    Z_i <- matrix(0, nrow = n_i, ncol = n.beta)
    if (length(cont_idx) > 0) Z_i[, cont_idx] <- Z_cont
    if (length(binary_idx) > 0) Z_i[, binary_idx] <- Z_bin
    Z_i
  })

  Z <- do.call(rbind, Z_list)
  colnames(Z) <- paste0("Z", seq_len(n.beta))

  U <- runif(N)
  linpred <- as.numeric(Z %*% beta)
  rate_mult <- gamma_subject * exp(linpred)
  W <- -log(U) / rate_mult

  if (baseline == "exponential") {
    pre_time <- W
  } else {
    pre_time <- sqrt((2 * W) / alpha)
  }

  mvec <- pmin(pre_time, max_time)

  calib_uniform <- function(target, mvec, iters = 1e3, tol = 1e-4) {
    if (all(!is.finite(mvec)) || all(mvec == 0)) return(1e-6)
    lo <- 1e-6
    hi <- max(mvec[is.finite(mvec)])
    if (!is.finite(hi) || hi <= 0) hi <- 1.0
    f <- function(c) mean(pmin(mvec / c, 1), na.rm = TRUE) - target
    while (f(hi) > 0) hi <- hi * 2
    for (k in 1:iters) {
      mid <- 0.5 * (lo + hi)
      fm <- f(mid)
      if (abs(fm) < tol) return(mid)
      if (fm > 0) lo <- mid else hi <- mid
    }
    0.5 * (lo + hi)
  }

  calib_exponential <- function(target, mvec, iters = 1e3, tol = 1e-4) {
    if (all(!is.finite(mvec)) || all(mvec == 0)) return(1e6)
    lo <- 1e-8
    hi <- 1.0
    g <- function(lambda) mean(1 - exp(-lambda * mvec), na.rm = TRUE) - target
    while (g(hi) < 0) hi <- hi * 2
    for (k in 1:iters) {
      mid <- 0.5 * (lo + hi)
      gm <- g(mid)
      if (abs(gm) < tol) return(mid)
      if (gm > 0) hi <- mid else lo <- mid
    }
    0.5 * (lo + hi)
  }

  calib_weibull_scale <- function(target, mvec, shape, iters = 1e3, tol = 1e-4) {
    if (all(!is.finite(mvec)) || all(mvec == 0)) return(1e6)
    lo <- 1e-8
    hi <- max(mvec[is.finite(mvec)])
    if (!is.finite(hi) || hi <= 0) hi <- 1.0
    g <- function(scale) mean(1 - exp(- (mvec / scale)^shape), na.rm = TRUE) - target
    while (g(hi) > 0) hi <- hi * 2
    while (g(lo) < 0) lo <- lo / 2
    for (k in 1:iters) {
      mid <- 0.5 * (lo + hi)
      gm <- g(mid)
      if (abs(gm) < tol) return(mid)
      if (gm > 0) lo <- mid else hi <- mid
    }
    0.5 * (lo + hi)
  }

  calib_lognormal_meanlog <- function(target, mvec, sdlog, iters = 1e3, tol = 1e-4) {
    if (all(!is.finite(mvec)) || all(mvec == 0)) return(0)
    eps <- 1e-12
    mm <- pmax(mvec, eps)
    lo <- -50
    hi <- 50
    g <- function(meanlog) mean(plnorm(mm, meanlog = meanlog, sdlog = sdlog), na.rm = TRUE) - target
    while (g(lo) > 0) lo <- lo - 25
    while (g(hi) < 0) hi <- hi + 25
    for (k in 1:iters) {
      mid <- 0.5 * (lo + hi)
      gm <- g(mid)
      if (abs(gm) < tol) return(mid)
      if (gm > 0) hi <- mid else lo <- mid
    }
    0.5 * (lo + hi)
  }

  if (censor_type == "none" || censor_rate <= 0) {
    C_random <- rep(Inf, N)
    censor_param_used <- NA_real_
  } else if (censor_type == "uniform") {
    c_max <- calib_uniform(censor_rate, mvec)
    C_random <- runif(N, 0, c_max)
    censor_param_used <- c_max
  } else if (censor_type == "exponential") {
    lambda_c <- calib_exponential(censor_rate, mvec)
    C_random <- rexp(N, rate = lambda_c)
    censor_param_used <- lambda_c
  } else if (censor_type == "weibull") {
    scale_c <- calib_weibull_scale(censor_rate, mvec, shape = censor_weibull_shape)
    C_random <- rweibull(N, shape = censor_weibull_shape, scale = scale_c)
    censor_param_used <- scale_c
  } else {
    meanlog_c <- calib_lognormal_meanlog(censor_rate, mvec, sdlog = censor_lognormal_sdlog)
    C_random <- rlnorm(N, meanlog = meanlog_c, sdlog = censor_lognormal_sdlog)
    censor_param_used <- meanlog_c
  }

  C_total <- pmin(C_random, max_time)
  delta <- as.numeric(pre_time <= C_total)
  time <- pmin(pre_time, C_total)
  actual_censor_rate <- mean(delta == 0)

  if (ties) {
    tt <- time
    finite_tt <- tt[is.finite(tt)]
    if (length(finite_tt) >= 2) {
      probs <- seq(0, 1, length.out = ties_levels + 1)
      brks <- unique(as.numeric(stats::quantile(finite_tt, probs = probs, type = 8, na.rm = TRUE)))
      if (length(brks) >= 3) {
        mids <- 0.5 * (brks[-1] + brks[-length(brks)])
        idx_bin <- cut(tt, breaks = brks, include.lowest = TRUE, labels = FALSE)
        keep <- !is.na(idx_bin)
        tt2 <- tt
        tt2[keep] <- mids[pmin(pmax(idx_bin[keep], 1), length(mids))]
        time <- tt2
      }
    }
  }

  out_df <- data.frame(
    stratum = stratum_id,
    status = delta,
    time = time,
    Z
  )

  out_list <- list(
    stratum = stratum_id,
    Z = Z,
    time = time,
    status = delta
  )

  list(
    data_combined = out_df,
    data = out_list,
    true_beta = beta,
    meta = list(
      n_stratum = n_stratum,
      stratum_size = stratum_size,
      gamma_stratum = gamma_stratum,
      censor_type = censor_type,
      target_censor_rate = censor_rate,
      actual_censor_rate = actual_censor_rate,
      censor_param_used = censor_param_used,
      max_time = max_time,
      mu_Z_used = mu_vec,
      sd_Z_used = sd_vec_all,
      baseline = baseline,
      alpha = alpha,
      censor_weibull_shape = if (censor_type == "weibull") censor_weibull_shape else NA_real_,
      censor_lognormal_sdlog = if (censor_type == "lognormal") censor_lognormal_sdlog else NA_real_,
      binary_idx = binary_idx,
      binary_prev = if (length(binary_idx) > 0) binary_prev_vec else numeric(0),
      rho_binary = if (length(binary_idx) > 0) rho_binary else NA_real_,
      ties = ties,
      ties_levels = if (ties) ties_levels else NA_integer_,
      beta_idx = beta_idx_use
    )
  )
}

#' Simulate stratified binary outcomes
#'
#' @description
#' Internal function to simulate stratified binary data (logistic or probit) with
#' random intercepts and no prevalence calibration.
#'
#' @param n_stratum Number of strata.
#' @param beta Numeric vector of coefficients (length p).
#' @param stratum.size.mean Mean stratum size (Poisson distributed).
#' @param rho Correlation parameter for Z within stratum.
#' @param link Link function, one of "logit" or "probit".
#' @param stratum_sd Standard deviation of stratum random intercepts.
#' @param seed Optional RNG seed.
#'
#' @return A list with combined data frame, data list, and metadata.
#'
#' @keywords internal
#' @export
sim.binary <- function(n_stratum,
                       beta,
                       stratum.size.mean = 80,
                       rho = 0.8,
                       link = c("logit","probit"),
                       stratum_sd = 0.5,
                       seed = NULL) {

  if (!is.null(seed)) set.seed(seed)
  link <- match.arg(tolower(link), c("logit","probit"))

  # checks
  if (!is.numeric(beta) || any(!is.finite(beta))) stop("beta must be a finite numeric vector.")
  p <- length(beta)
  if (p < 1L) stop("beta must have positive length.")
  if (stratum_sd < 0) stop("stratum_sd must be >= 0.")
  if (!is.finite(rho)) stop("rho must be finite.")

  # --- stratum sizes (may be zero) & random intercepts ---
  stratum_size <- rpois(n_stratum, stratum.size.mean)   # no lower bound
  N <- sum(stratum_size)
  if (N == 0L) stop("All strata have size 0; increase stratum.size.mean or n_stratum.")

  stratum_id    <- rep(seq_len(n_stratum), stratum_size)
  theta_stratum <- if (stratum_sd > 0) rnorm(n_stratum, 0, stratum_sd) else rep(0, n_stratum)
  theta_subject <- rep(theta_stratum, times = stratum_size)

  # --- covariates Z with within-stratum correlation ---
  rZ <- function(i, rho, p, n_i) {
    if (n_i == 0L) return(matrix(numeric(0), nrow = 0, ncol = p))
    mu_i    <- (theta_stratum[i] * rho / 0.4) * rep(1, p)
    Sigma_i <- diag(1 - rho, p) + (rho - rho^2) * matrix(1, p, p)
    MASS::mvrnorm(n = n_i, mu = mu_i, Sigma = Sigma_i)
  }
  Z_list <- lapply(seq_len(n_stratum), function(i) rZ(i, rho, p, stratum_size[i]))
  Z <- do.call(rbind, Z_list)
  colnames(Z) <- paste0("Z", seq_len(p))

  # --- probabilities (alpha0 fixed at 0) & sampling ---
  linpred <- as.numeric(theta_subject + Z %*% beta)  # alpha0 = 0
  inv_link <- switch(link, logit = plogis, probit = pnorm)
  p_hat <- inv_link(linpred)
  y <- rbinom(N, size = 1, prob = p_hat)

  # --- outputs ---
  out_df <- data.frame(
    stratum = stratum_id,
    y       = y,
    Z
  )
  out_list <- list(
    stratum = stratum_id,
    Z       = Z,
    y       = y
  )

  list(
    data_combined = out_df,
    data          = out_list,
    true_beta     = as.numeric(beta),
    char = list(
      stratum      = "stratum",
      Z.char       = colnames(Z),
      Outcome.char = "y"
    ),
    meta = list(
      n_stratum     = n_stratum,
      stratum_size  = stratum_size,
      theta_stratum = theta_stratum,
      link          = link,
      alpha0        = 0,
      stratum_sd    = stratum_sd,
      rho           = rho,
      actual_prev   = mean(y)
    )
  )
}


#' Simulate 1:m matched case-control data with mean/SD control
#'
#' @description
#' Internal function to simulate 1:m matched data. Each stratum contains exactly one case.
#' The case is sampled with probability proportional to exp(eta), where
#' eta = theta_stratum + Z %*% beta.
#'
#' @param n_stratum Number of matched strata (sets).
#' @param m Number of controls per case (>=1).
#' @param beta Numeric vector of coefficients (length p).
#' @param rho Correlation parameter for Z within stratum (equicorrelation).
#' @param mu_Z Mean vector for Z. Scalar or length p.
#' @param sd_Z Standard deviation vector for Z. Scalar or length p, must be positive.
#' @param stratum_sd SD of stratum random intercepts.
#' @param seed Optional RNG seed.
#'
#' @return A list containing matched data frames and simulation metadata.
#'
#' @keywords internal
#' @export
sim.matched_cc <- function(n_stratum,
                           m,
                           beta,
                           rho = 0.8,
                           mu_Z = 0,
                           sd_Z = 1,
                           stratum_sd = 0.5,
                           seed = NULL) {
  if (!is.null(seed)) set.seed(seed)

  if (!is.numeric(beta) || any(!is.finite(beta))) stop("beta must be numeric and finite.")
  p <- length(beta)
  if (p < 1L) stop("beta must have positive length.")

  if (!is.numeric(n_stratum) || length(n_stratum) != 1L || n_stratum < 1L || n_stratum != as.integer(n_stratum)) {
    stop("n_stratum must be an integer >= 1.")
  }
  n_stratum <- as.integer(n_stratum)

  if (!is.numeric(m) || length(m) != 1L || m < 1L || m != as.integer(m)) {
    stop("m must be an integer >= 1.")
  }
  m <- as.integer(m)

  if (!is.finite(rho) || rho < 0 || rho >= 1) stop("rho must be in [0, 1).")
  if (!is.finite(stratum_sd) || stratum_sd < 0) stop("stratum_sd must be finite and >= 0.")

  if (length(mu_Z) == 1L) {
    mu_vec <- rep(as.numeric(mu_Z), p)
  } else if (length(mu_Z) == p) {
    mu_vec <- as.numeric(mu_Z)
  } else {
    stop("mu_Z must be a scalar or a numeric vector of length p.")
  }
  if (any(!is.finite(mu_vec))) stop("mu_Z must be finite.")

  if (length(sd_Z) == 1L) {
    sd_vec <- rep(as.numeric(sd_Z), p)
  } else if (length(sd_Z) == p) {
    sd_vec <- as.numeric(sd_Z)
  } else {
    stop("sd_Z must be a scalar or a numeric vector of length p.")
  }
  if (any(!is.finite(sd_vec)) || any(sd_vec <= 0)) stop("sd_Z must be positive and finite.")

  theta_stratum <- if (stratum_sd > 0) rnorm(n_stratum, 0, stratum_sd) else rep(0, n_stratum)

  set_size <- m + 1L
  N <- n_stratum * set_size

  R <- diag(1 - rho, p) + matrix(rho, p, p)
  D <- diag(sd_vec, p)
  Sigma <- D %*% R %*% D

  Z_all <- matrix(NA_real_, nrow = N, ncol = p)
  y_all <- integer(N)
  stratum_all <- integer(N)

  row_start <- 1L
  for (s in seq_len(n_stratum)) {
    idx <- row_start:(row_start + set_size - 1L)

    Zi <- MASS::mvrnorm(n = set_size, mu = mu_vec, Sigma = Sigma)
    eta <- as.numeric(theta_stratum[s] + Zi %*% beta)

    w <- exp(eta - max(eta))
    pr <- w / sum(w)
    case_pos <- sample.int(set_size, 1L, prob = pr)

    yi <- integer(set_size)
    yi[case_pos] <- 1L

    Z_all[idx, ] <- Zi
    y_all[idx] <- yi
    stratum_all[idx] <- s

    row_start <- row_start + set_size
  }

  colnames(Z_all) <- paste0("Z", seq_len(p))
  out_df <- data.frame(stratum = stratum_all, y = y_all, Z_all)
  out_list <- list(stratum = stratum_all, Z = Z_all, y = y_all)

  list(
    data_combined = out_df,
    data = out_list,
    true_beta = as.numeric(beta),
    char = list(
      stratum = "stratum",
      Z.char = colnames(Z_all),
      Outcome.char = "y"
    ),
    meta = list(
      n_stratum = n_stratum,
      m = m,
      set_size = set_size,
      theta_stratum = theta_stratum,
      stratum_sd = stratum_sd,
      rho = rho,
      mu_Z = mu_vec,
      sd_Z = sd_vec,
      case_prop = 1 / set_size
    )
  )
}



#' Simulate Low-Dimensional Survival Data for Integration
#'
#' @description
#' Internal function. Generates simulated low-dimensional survival datasets for internal
#' (training/testing) and external cohorts with varying heterogeneity levels via latent groups.
#'
#' @param n_int Number of subjects in the internal training set.
#' @param n_test Number of subjects in the internal test set.
#' @param n_ext Number of subjects in the external dataset.
#' @param beta_true True regression coefficients.
#' @param int_cens_target Target censoring rate for internal data.
#' @param ext_cens_target Target censoring rate for external data.
#' @param lambda0,nu0 Weibull baseline hazard parameters.
#' @param heterogeneity Numeric. Controls the mixture difference between cohorts.
#' @param seed Random seed.
#'
#' @return A list containing \code{external}, \code{internal_train}, and \code{internal_test} datasets.
#'
#' @keywords internal
#' @export
sim_integration <- function(n_int = 200, n_test = 1000, n_ext = 1000,
                            beta_true = c(0.3, -0.3,  0.3, -0.3,  0.3, -0.3),
                            int_cens_target = 0.3, ext_cens_target = 0.5,
                            lambda0 =  1, nu0 = 2,
                            heterogeneity = 1.0,
                            seed = NULL){

  if (!is.null(seed)){
    set.seed(seed)
  }

  names(beta_true) <- paste0("Z", 1:6)
  df_ext <- sim(n_ext, ext_cens_target, beta_true = beta_true, pL_group = heterogeneity, lambda0 = lambda0, nu0 = nu0)

  pL_internal <- 1.0
  df_tr <- sim(n_int, int_cens_target, beta_true = beta_true, pL_group = pL_internal, lambda0 = lambda0, nu0 = nu0)
  df_te <- sim(n_test, int_cens_target, beta_true = beta_true, pL_group = pL_internal, lambda0 = lambda0, nu0 = nu0)

  return(list(external = df_ext,
              internal_train=df_tr,
              internal_test=df_te))
}


# --- Helper functions (Internal Use) ---

simulate_survival_weibull <- function(eta, lambda = lambda0, nu = nu0) {
  U <- runif(length(eta))
  (-log(U) / (lambda * exp(eta)))^(1/nu)
}

sim <- function(n, target_cens, beta_true, pL_group = 1.0, lambda0 = 1, nu0 = 2) {
  Z1Z2 <- simu_z_AR1(n, 2, rho=0.5)
  colnames(Z1Z2) <- c("Z1","Z2")
  Z3   <- rbinom(n, 1, 0.5)
  Z4   <- rbinom(n, 1, 0.5)
  L    <- rbinom(n, 1, pL_group)  # a length-n vector of latent group indicator (0/1)
  Z5   <- rnorm(n, mean= 2*L, sd=1)  # Z5 & Z6 from a mixture of two populations
  Z6   <- rnorm(n, mean=-2*L, sd=1)
  X    <- cbind(Z1Z2, Z3=Z3, Z4=Z4, Z5=Z5, Z6=Z6)
  eta  <- drop(as.matrix(X) %*% beta_true)
  Tt   <- simulate_survival_weibull(eta, lambda=lambda0, nu=nu0)
  ub   <- tune_censoring_uniform(Tt, target=target_cens)
  Cc   <- runif(n, 0, ub)
  status <- as.integer(Tt <= Cc)
  time   <- ifelse(status==1, Tt, Cc)
  order_cols(data.frame(X, status=status, time=time), z_names=paste0("Z",1:6))
}


AR1_corr <- function(rho, m) {
  if (m == 1) return(matrix(1,1,1))
  out <- outer(1:m, 1:m, function(i,j) rho^abs(i-j))
  diag(out) <- 1
  out
}


simu_z_AR1 <- function(n, p_cont, rho=0.5) {
  mvtnorm::rmvnorm(n, mean=rep(0,p_cont), sigma=AR1_corr(rho, p_cont))
}

tune_censoring_uniform <- function(event_time, target=0.5, max_iter=30) {
  q <- stats::quantile(event_time, probs=c(0.2, 0.5, 0.95), type=7, na.rm=TRUE, names=FALSE)
  ub_min <- if (is.finite(q[1]) && q[1] > 0) q[1] else 1e-3
  ub_max <- if (is.finite(q[3]) && q[3] > 0) q[3] else max(1, mean(event_time, na.rm=TRUE))
  ub     <- if (is.finite(q[2]) && q[2] > 0) q[2] else mean(event_time[event_time>0], na.rm=TRUE)
  if (!is.finite(ub) || ub <= 0) ub <- 1
  ub <- min(max(ub, ub_min), ub_max)
  best_ub <- ub; best_diff <- Inf
  for (i in 1:max_iter) {
    C <- runif(length(event_time), 0, ub)
    delta <- as.integer(event_time <= C)
    rate  <- mean(1 - delta) # censoring rate
    d <- abs(rate - target)
    if (d < best_diff) { best_diff <- d; best_ub <- ub }
    ub <- if (rate < target) ub*0.85 else ub*1.15
    ub <- min(max(ub, ub_min), ub_max)
  }
  best_ub
}

order_cols <- function(df, z_names) {
  keep <- intersect(z_names, names(df))
  miss <- setdiff(z_names, keep)
  if (length(miss)) for (m in miss) df[[m]] <- 0
  df <- df[, c(z_names, "status", "time"), drop=FALSE]
  rownames(df) <- NULL
  df
}

